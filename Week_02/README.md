学习笔记

## GC总结：

### 整体思路：

1、硬件设备配置越来越高，如何发挥硬件的性能提高GC效率

2、使用分治思想，对对象进行越来越细的分类，方便管理，同时可以根据不同类别对象的特点使用不同的回收策略

### Serial GC(串行GC)

Serial GC 对年轻代使用mark-copy(标记-复制) 算法, 对老年代使用mark-sweep-compact(标记-清除-整理)算法. 顾名思义, 两者都是**单线程**的垃圾收集器,不能进行并行处理。两者都会触发全线暂停(STW),停止所有的应用线程。

### Parallel GC(并行GC)

并行垃圾收集器这一类组合, 在年轻代使用标记-复制(mark-copy)算法, 在老年代使用标记-清除-整理(mark-sweep-compact)算法。年轻代和老年代的垃圾回收都会触发STW事件,暂停所有的应用线程来执行垃圾收集。两者在执行 标记和 复制/整理阶段时都使用**多个线程**, 因此得名“**(Parallel)**”。通过并行执行, 使得GC时间大幅减少。

### CMS

全称 Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用`标记-清除`算法，多线程，优点是并发收集（用户线程可以和 GC 线程同时工作），停顿小。

初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。

并发收集：

> 指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在 CMS 中用户线程还是需要停顿的，只是非常短，GC 线程在另一个 CPU 上执行）；

并行收集：

> 指多个 GC 线程并行工作，但此时用户线程是暂停的；

### G1
    
G1 GC，全称Garbage-First Garbage Collector

## 各个GC的对比

| 收集器            |      |        |                    | 目标         | 适用场景                               | 可以与cms配合 |
| ----------------- | ---- | ------ | ------------------ | ------------ | -------------------------------------- | ------------- |
| Serial            | 串行 | 新生代 | 复制算法           | 响应速度优先 | 单CPU环境下的Client模式                | 是            |
| Serial Old        | 串行 | 老年代 | 标记-整理          | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备方案 |               |
| parNew            | 并行 | 新生代 | 复制算法           | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合     | 是            |
| Parallel Scavenge | 并行 | 新生代 | 复制算法           | 吞吐量优先   | 在后台运算而不需要太多交互的任务       |               |
| Parrllel Old      | 并行 | 老年代 | 标记-整理          | 吞吐量优先   | 在后台运算而不需要太多交互的任务       |               |
| CMS               | 并发 | 老年代 | 标记-清除          | 响应速度优先 | 集中在互联网网站或者B/S系统上的应用    |               |
| G1                | 并发 | both   | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用,将来会替换CMS÷          |               |
